import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';
import { MapContainer, TileLayer, Marker, useMapEvents } from 'react-leaflet';
import 'leaflet/dist/leaflet.css';
import L from 'leaflet';
import { Input } from '@/components/ui/input';
import { Button } from '@/components/ui/button';
import { LocateFixed, Search, Loader2, MapPin, ExternalLink, AlertCircle } from 'lucide-react';
import { InvokeLLM } from '@/integrations/Core';

// Fix for default marker icon
delete L.Icon.Default.prototype._getIconUrl;
L.Icon.Default.mergeOptions({
  iconRetinaUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon-2x.png',
  iconUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon.png',
  shadowUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-shadow.png',
});

const LocationMarker = ({ position, setPosition, onLocationChange, setIsFetchingAddress }) => {
  const map = useMapEvents({
    click(e) {
      setPosition(e.latlng);
      map.flyTo(e.latlng, map.getZoom());
    },
  });

  // Create debounce function using useMemo to avoid recreating it
  const debounce = useMemo(() => {
    return (func, wait) => {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    };
  }, []);

  // Create the address fetching function
  const getAddress = useCallback(async (pos) => {
    setIsFetchingAddress(true);
    try {
      const addressString = await InvokeLLM({
        prompt: `What is the address for latitude ${pos.lat} and longitude ${pos.lng}? Respond with only the full address as a plain string.`,
        add_context_from_internet: true,
      });

      if (addressString && typeof addressString === 'string') {
        onLocationChange({
          address: addressString.trim(),
          lat: pos.lat,
          lng: pos.lng
        });
      } else {
        throw new Error("Invalid address format received.");
      }
    } catch (error) {
      console.error('Error fetching address via LLM:', error);
      
      // Fallback to coordinates when API fails
      const fallbackAddress = `Location: ${pos.lat.toFixed(4)}, ${pos.lng.toFixed(4)}`;
      onLocationChange({
        address: fallbackAddress,
        lat: pos.lat,
        lng: pos.lng,
        isCoordinatesOnly: true
      });
    } finally {
      setIsFetchingAddress(false);
    }
  }, [onLocationChange, setIsFetchingAddress]);

  // Create debounced version of the address fetching function
  const debouncedGetAddress = useMemo(() => {
    return debounce(getAddress, 1000);
  }, [debounce, getAddress]);

  useEffect(() => {
    if (position) {
      debouncedGetAddress(position);
    }
  }, [position, debouncedGetAddress]);

  return position === null ? null : <Marker position={position}></Marker>;
};

export default function LocationPicker({ address = "", onLocationChange, showMap = true }) {
  const [position, setPosition] = useState(null);
  const [mapCenter, setMapCenter] = useState([20.5937, 78.9629]); // Default to India
  const [zoom, setZoom] = useState(5);
  const [searchQuery, setSearchQuery] = useState("");
  const [isLocating, setIsLocating] = useState(false);
  const [isSearching, setIsSearching] = useState(false);
  const [isFetchingAddress, setIsFetchingAddress] = useState(false);
  const [selectedAddress, setSelectedAddress] = useState(address);
  const [manualAddress, setManualAddress] = useState(address);
  const [locationError, setLocationError] = useState("");
  const mapRef = useRef();

  useEffect(() => {
    setManualAddress(address);
    setSelectedAddress(address);
  }, [address]);

  const handleGetCurrentLocation = () => {
    setIsLocating(true);
    setLocationError("");
    
    if (!navigator.geolocation) {
      setLocationError("Geolocation is not supported by this browser.");
      setIsLocating(false);
      return;
    }

    navigator.geolocation.getCurrentPosition(
      (pos) => {
        const { latitude, longitude } = pos.coords;
        const newPos = { lat: latitude, lng: longitude };
        setPosition(newPos);
        setMapCenter([latitude, longitude]);
        setZoom(15);
        if (mapRef.current) {
          mapRef.current.flyTo(newPos, 15);
        }
        setIsLocating(false);
      },
      (error) => {
        console.error("Error getting location:", error);
        let errorMessage = "Could not get your location. ";
        switch(error.code) {
          case error.PERMISSION_DENIED:
            errorMessage += "Please grant location permission and try again.";
            break;
          case error.POSITION_UNAVAILABLE:
            errorMessage += "Location information is unavailable.";
            break;
          case error.TIMEOUT:
            errorMessage += "Location request timed out.";
            break;
          default:
            errorMessage += "An unknown error occurred.";
            break;
        }
        setLocationError(errorMessage);
        setIsLocating(false);
      },
      { enableHighAccuracy: true, timeout: 10000, maximumAge: 300000 }
    );
  };
  
  const handleSearch = async (e) => {
    e.preventDefault();
    if (!searchQuery.trim()) return;
    
    setIsSearching(true);
    setLocationError("");
    
    try {
        // Add retry logic with exponential backoff
        let retryCount = 0;
        const maxRetries = 2;
        
        const searchWithRetry = async () => {
          try {
            const result = await InvokeLLM({
              prompt: `Find the geographic coordinates and full address for the location: "${searchQuery}". Provide a precise latitude and longitude.`,
              add_context_from_internet: true,
              response_json_schema: {
                  type: "object",
                  properties: {
                      lat: { type: "number", description: "Latitude" },
                      lon: { type: "number", description: "Longitude" },
                      address: { type: "string", description: "The full, formatted address" }
                  },
                  required: ["lat", "lon", "address"]
              }
            });

            if (result && result.lat && result.lon) {
                const newPos = { lat: result.lat, lng: result.lon };
                setPosition(newPos);
                setMapCenter([result.lat, result.lon]);
                setZoom(15);
                if (mapRef.current) {
                    mapRef.current.flyTo(newPos, 15);
                }
                
                // Update with the found address
                onLocationChange({
                  address: result.address || searchQuery,
                  lat: result.lat,
                  lng: result.lon
                });
            } else {
                throw new Error("Location not found");
            }
          } catch (error) {
            if (error.message.includes('429') && retryCount < maxRetries) {
              retryCount++;
              const delay = Math.pow(2, retryCount) * 1000; // Exponential backoff
              await new Promise(resolve => setTimeout(resolve, delay));
              return searchWithRetry();
            }
            throw error;
          }
        };

        await searchWithRetry();
        
    } catch (error) {
        console.error('Error searching location:', error);
        if (error.message.includes('429')) {
          setLocationError("Search temporarily unavailable due to high demand. Please try again in a moment or enter the address manually.");
        } else {
          setLocationError("Location not found. Please try a different search term or enter the address manually.");
        }
    } finally {
        setIsSearching(false);
    }
  };

  const handleLocationUpdate = (data) => {
    onLocationChange(data);
    setSelectedAddress(data.address);
    setLocationError("");
  };

  const handleManualAddressChange = (e) => {
    const newAddress = e.target.value;
    setManualAddress(newAddress);
    onLocationChange({
      address: newAddress,
      lat: position?.lat || null,
      lng: position?.lng || null
    });
    setLocationError("");
  };

  const openInGoogleMaps = () => {
    if (position) {
      const url = `https://maps.google.com/?q=${position.lat},${position.lng}`;
      window.open(url, '_blank');
    }
  };

  const isLoading = isLocating || isSearching || isFetchingAddress;

  return (
    <div className="space-y-4">
      {/* Error Display */}
      {locationError && (
        <div className="p-3 bg-red-50 border border-red-200 rounded-xl">
          <div className="flex items-start gap-2">
            <AlertCircle className="w-4 h-4 text-red-600 mt-0.5 flex-shrink-0" />
            <p className="text-sm text-red-700">{locationError}</p>
          </div>
        </div>
      )}

      {/* Manual Address Input */}
      <div className="space-y-2">
        <label className="text-sm font-medium text-slate-700">
          Address *
        </label>
        <div className="relative">
          <MapPin className="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-slate-400" />
          <Input
            placeholder="Enter your complete address..."
            value={manualAddress}
            onChange={handleManualAddressChange}
            className="pl-10 border-slate-200 rounded-xl"
          />
        </div>
      </div>

      {showMap && (
        <>
          {/* Map Controls */}
          <div className="flex gap-2">
            <form onSubmit={handleSearch} className="flex-1">
              <div className="flex gap-2">
                <Input
                  placeholder="Search address..."
                  value={searchQuery}
                  onChange={(e) => setSearchQuery(e.target.value)}
                  className="border-slate-200 rounded-xl"
                  disabled={isLoading}
                />
                <Button type="submit" variant="outline" size="icon" className="rounded-xl" disabled={isLoading}>
                  {isSearching ? <Loader2 className="w-4 h-4 animate-spin" /> : <Search className="w-4 h-4" />}
                </Button>
              </div>
            </form>
            <Button 
              type="button" 
              onClick={handleGetCurrentLocation} 
              disabled={isLoading}
              variant="outline"
              className="rounded-xl whitespace-nowrap"
            >
              {isLocating ? <Loader2 className="w-4 h-4 animate-spin" /> : <LocateFixed className="w-4 h-4 mr-1" />}
              <span className="hidden sm:inline">GPS</span>
            </Button>
          </div>
          
          {/* Selected Location Info */}
          {selectedAddress && position && (
            <div className="p-3 bg-green-50 border border-green-200 rounded-xl">
              <div className="flex items-start justify-between gap-2">
                <div className="flex-1">
                  <p className="text-sm text-green-800 font-medium flex items-center gap-2">
                    {isFetchingAddress && <Loader2 className="w-3 h-3 animate-spin" />}
                    Selected Location:
                  </p>
                  <p className="text-xs text-green-700 mt-1">{selectedAddress}</p>
                  <p className="text-xs text-green-600 mt-1">
                    Coordinates: {position.lat.toFixed(6)}, {position.lng.toFixed(6)}
                  </p>
                </div>
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={openInGoogleMaps}
                  className="text-green-700 border-green-300 hover:bg-green-100"
                >
                  <ExternalLink className="w-3 h-3 mr-1" />
                  Maps
                </Button>
              </div>
            </div>
          )}
          
          {/* Interactive Map */}
          <div className="h-64 w-full rounded-xl overflow-hidden border-2 border-slate-200">
            <MapContainer
              ref={mapRef}
              center={mapCenter}
              zoom={zoom}
              scrollWheelZoom={true}
              style={{ height: '100%', width: '100%' }}
            >
              <TileLayer
                attribution='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
              />
              <LocationMarker 
                position={position} 
                setPosition={setPosition} 
                onLocationChange={handleLocationUpdate}
                setIsFetchingAddress={setIsFetchingAddress}
              />
            </MapContainer>
          </div>
          
          <p className="text-xs text-slate-500 text-center">
            Tap on the map to pinpoint your exact location. Address lookup may be temporarily limited.
          </p>
        </>
      )}
    </div>
  );
}